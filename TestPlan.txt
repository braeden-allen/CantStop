TEST PLAN - MODULE 1 (DICE)

To meet the expectations for this module, we aim to extensively test all possible outcomes of our code.
1. We must make sure that the dice will produce pseudo random values in the range of 1..6 upon each roll
    To do this, we will use the unitDice() function from the UnitTest class to output into a .txt file and
    ensure that all values that are produced fall within the range of 1..6
2. We must make sure that the destructor will work for the Die values
    To do ensure successful run of the destructor, we will make sure that 0 errors are produced upon calling
    and instance of the class, which will prove success

----------------------------------------------------------------------------------------------------------------------

TEST PLAN - MODULE 2 (PLAYER)

To meet the expectations of this module, we aim to test all possibilities of our code.
1. To ensure that the proper player information will be printed upon creation
    To achieve this, we will use the unitPlayer() function at the bottom of the main.cpp file to output
    information regarding the characteristics of each individual player, to ensure that different types of
    ENum colors successfully work.
2. To ensure that the boolean function, wonColumn() works effectively.
    To achieve this aspect of testsing, we will print an output 3 times, and on the third time, we should
    see an output that will print a sequence of numbers, being 0, 0, 1. The one will represent that the game
    has been won

----------------------------------------------------------------------------------------------------------------------

TEST PLAN - MODULE 3 (COLUMN)

To meet the expectations of this module, we aim to test all possibilities of our code, column.cpp
1. To ensure that column information will be printed upon creation.
    To achieve this, we used a unitColumn() function in the main.cpp file to output information about columns,
    which includes, a constructor to accurately create and initialize a column, a columnState() function that will
    return the state of the column, a startTower() function that will place a tower in a given column, a move()
    function that will advance the tower one square in the column, and potentially capture it, a stop() function to
    allow for the payer to end his or her game, and a print() function to print the status of each column of the game.
