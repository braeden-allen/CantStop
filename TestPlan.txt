TEST PLAN - MODULE 1 (DICE)

To meet the expectations for this module, we aim to extensively test all possible outcomes of our code.
1. We must make sure that the dice will produce pseudo random values in the range of 1..6 upon each roll
    To do this, we will use the unitDice() function from the UnitTest class to output into a .txt file and
    ensure that all values that are produced fall within the range of 1..6
2. We must make sure that the destructor will work for the Die values
    To do ensure successful run of the destructor, we will make sure that 0 errors are produced upon calling
    and instance of the class, which will prove success

----------------------------------------------------------------------------------------------------------------------

TEST PLAN - MODULE 2 (PLAYER)

To meet the expectations of this module, we aim to test all possibilities of our code.
1. To ensure that the proper player information will be printed upon creation
    To achieve this, we will use the unitPlayer() function at the bottom of the main.cpp file to output
    information regarding the characteristics of each individual player, to ensure that different types of
    ENum colors successfully work.
2. To ensure that the boolean function, wonColumn() works effectively.
    To achieve this aspect of testsing, we will print an output 3 times, and on the third time, we should
    see an output that will print a sequence of numbers, being 0, 0, 1. The one will represent that the game
    has been won

----------------------------------------------------------------------------------------------------------------------

TEST PLAN - MODULE 3 (COLUMN)

To meet the expectations of this module, we aim to test all possibilities of our code, column.cpp
1. To ensure that column information will be printed upon creation.
    To achieve this, we used a unitColumn() function in the main.cpp file to output information about columns,
    which includes, a constructor to accurately create and initialize a column, a columnState() function that will
    return the state of the column, a startTower() function that will place a tower in a given column, a move()
    function that will advance the tower one square in the column, and potentially capture it, a stop() function to
    allow for the payer to end his or her game, and a print() function to print the status of the columns after each
    function call.

----------------------------------------------------------------------------------------------------------------------

TEST PLAN - MODULE 4 (GAME)

To meet the expectations of this module, we aim to test all possibilities of our code, game.cpp
1. Create an instance of game, which constructs two players with a name and a color
2. To allow for input for these fields, which will be entered by the user in the console
3. To construct two columns, of different lengths, column 2, with has 3 squares, and column 7, which has the length
   of 13 squares.
4. To place towers in each column, and to make moves on each column
5. Capture a single column, column 2.

----------------------------------------------------------------------------------------------------------------------

TEST PLAN - MODULE 5 (BOARD)

To meet the expectations of this module, we aim to test all possibilities of our code, board.cpp
1. To ensure a board and players can accurately be created and displayed initially. To achieve this, we used unitBoard()
    to create an instance of two players, rolled die, and a sketch of the board before any start.
2. To accurately place towers and make moves on the board. To achieve this, we would use the board.getTower, with the
    column int as a parameter to place a tower and move on that column, and eventually print the board after stopping
    the players turn, capturing teh columns.
3. To ensure our logic and validation worked correctly, we made player2 attempt to start a tower on columns 2, 7, which
    will present an error message saying that these cannot be started, as they will be captured.
4. To ensure both players can have a go at a column. To do this, we will attempt to set a tower for P2 on a new column,
    and move up and down that column.
5. To ensure that the bust function works. This will be implemented by calling the bust on P2, then proceeding to print
    the board, which now should say available instead of pending, when the player was in the column.
6. To print the Scores of each player. To do this, at the end of the game, each player score will be displayed to show
    that the logic behind keeping score works as required.

----------------------------------------------------------------------------------------------------------------------